# GOF Comportamental - Template Method

## 1. Introdução 

O **Template Method** é um padrão de projeto comportamental que define o esqueleto de um algoritmo em uma superclasse, mas permite que as subclasses redefinam certas etapas do algoritmo sem alterar sua estrutura geral (Gamma et al., 1994). O objetivo principal é permitir que as subclasses implementem as partes variáveis do algoritmo, enquanto a superclasse mantém a consistência da sequência de execução.

## 2. Contexto no Projeto

Para aplicar o padrão **Template Method** no projeto, foi necessário modelar o processo de análise de consumo (seja de água ou energia) como um algoritmo com passos fixos e passos variáveis.

A implementação pode ser observada no arquivo `App/consumo/servicos/consumo_template.py`, especificamente na classe abstrata **`ConsumoTemplate`** e nas suas subclasses concretas **`ConsumoAgua`** e **`ConsumoEnergia`**.

O propósito é:
1.  **Definir a sequência de análise de consumo** (calcular, obter média, verificar alerta, gerar feedback, atribuir tokens) de forma fixa na classe `ConsumoTemplate`.
2.  **Permitir que cada tipo de consumo** (Água e Energia) **implemente seus próprios detalhes** (como o cálculo exato do consumo, a média de referência e a regra de alerta) nas suas respectivas subclasses.

## 3. Metodologia

A organização do código seguiu a lógica de separar o esqueleto do algoritmo (o "Template Method" `analisar_consumo`) das implementações específicas (os "Primitive Operations" abstratos).

A estrutura de pastas sugere a criação de um novo módulo `consumo` dentro de `App`, com a implementação do padrão em `App/consumo/servicos/consumo_template.py`.

A classe abstrata `ConsumoTemplate` utiliza o módulo `abc` do Python para definir os métodos abstratos (`calcular_consumo`, `obter_media`, `verificar_alerta`) que **devem ser implementados** pelas subclasses. O método `analisar_consumo` é o **Template Method**, que chama esses passos em uma ordem predefinida.

O **diagrama de classes** para este padrão foi elaborado a partir da modelagem do sistema, garantindo que a estrutura de herança e as responsabilidades de cada classe estivessem claras antes da codificação.

## 4. Template Method implementado no projeto

A seguir, está o código em Python que implementa o padrão Template Method para análise de consumo:

```python
from abc import ABC, abstractmethod
from typing import Dict, Any

class ConsumoTemplate(ABC):
    """
    Classe Abstrata que define o esqueleto do algoritmo para análise de consumo.
    Implementa o padrão de projeto Template Method.
    """

    def __init__(self, email_usuario: str):
        """Inicializa com o email do usuário."""
        self.email_usuario = email_usuario

    def analisar_consumo(self, dados_usuario: Dict[str, Any]) -> Dict[str, Any]:
        """
        Template Method: Define a sequência de passos para analisar o consumo.
        Os passos concretos são delegados às subclasses.
        """
        # 1. Calcular o consumo específico (passo abstrato)
        consumo_atual = self.calcular_consumo(dados_usuario)

        # 2. Obter a média histórica ou meta (passo abstrato)
        media_historica = self.obter_media()

        # 3. Verificar se o consumo está acima da média/meta (passo abstrato)
        alerta_necessario = self.verificar_alerta(consumo_atual, media_historica)

        # 4. Gerar a mensagem de alerta/feedback (passo concreto)
        mensagem_feedback = self.gerar_alerta(alerta_necessario, consumo_atual, media_historica)

        # 5. Atribuir tokens com base no consumo (passo concreto/hook)
        tokens_atribuidos = self.atribuir_tokens(consumo_atual, media_historica)

        return {
            "email_usuario": self.email_usuario,
            "consumo_atual": consumo_atual,
            "media_historica": media_historica,
            "alerta_necessario": alerta_necessario,
            "mensagem_feedback": mensagem_feedback,
            "tokens_atribuidos": tokens_atribuidos
        }

    # --- Métodos Abstratos (Primitivos) ---

    @abstractmethod
    def calcular_consumo(self, dados_usuario: Dict[str, Any]) -> float:
        """Calcula o consumo específico (e.g., água ou energia) a partir dos dados do usuário."""
        pass

    @abstractmethod
    def obter_media(self) -> float:
        """Obtém a média histórica de consumo ou a meta de consumo para comparação."""
        pass

    @abstractmethod
    def verificar_alerta(self, consumo: float, media: float) -> bool:
        """Verifica se o consumo está acima da média ou meta, indicando a necessidade de alerta."""
        pass

    # --- Métodos Concretos (Hooks e Passos Padrão) ---

    def gerar_alerta(self, alerta: bool, consumo: float, media: float) -> str:
        """Gera a mensagem de alerta ou feedback para o usuário."""
        if alerta:
            excesso = consumo - media
            return (f"ALERTA! Seu consumo ({consumo:.2f}) excedeu a média/meta ({media:.2f}) "
                    f"em {excesso:.2f}. Considere medidas de economia.")
        else:
            economia = media - consumo
            return (f"Parabéns! Seu consumo ({consumo:.2f}) está abaixo da média/meta ({media:.2f}). "
                    f"Você economizou {economia:.2f}!")

    def atribuir_tokens(self, consumo: float, media: float) -> int:
        """
        Hook: Atribui tokens. Implementação padrão: 
        Tokens são atribuídos apenas se o consumo for menor ou igual à média/meta.
        """
        if consumo <= media:
            # Atribui 10 tokens por unidade economizada (exemplo)
            economia = media - consumo
            return int(economia * 10)
        return 0

class ConsumoAgua(ConsumoTemplate):
    """Implementação concreta para a análise de consumo de Água."""

    def calcular_consumo(self, dados_usuario: Dict[str, Any]) -> float:
        """Simula o cálculo do consumo de água (em litros)."""
        return float(dados_usuario.get("consumo_agua_litros", 0.0))

    def obter_media(self) -> float:
        """Simula a obtenção da média histórica de consumo de água (em litros)."""
        return 15000.0

    def verificar_alerta(self, consumo: float, media: float) -> bool:
        """Verifica se o consumo de água excedeu a média."""
        return consumo > media * 1.1

class ConsumoEnergia(ConsumoTemplate):
    """Implementação concreta para a análise de consumo de Energia."""

    def calcular_consumo(self, dados_usuario: Dict[str, Any]) -> float:
        """Simula o cálculo do consumo de energia (em kWh)."""
        return float(dados_usuario.get("consumo_energia_kwh", 0.0))

    def obter_media(self) -> float:
        """Simula a obtenção da média histórica de consumo de energia (em kWh)."""
        return 300.0

    def verificar_alerta(self, consumo: float, media: float) -> bool:
        """Verifica se o consumo de energia excedeu a média."""
        return consumo > media * 1.05
```

O método **`analisar_consumo`** é o Template Method. Ele garante que a ordem de execução dos passos seja sempre a mesma: `calcular_consumo` -> `obter_media` -> `verificar_alerta` -> `gerar_alerta` -> `atribuir_tokens`.

Os métodos **`calcular_consumo`**, **`obter_media`** e **`verificar_alerta`** são métodos abstratos que devem ser implementados pelas subclasses. Por exemplo, `ConsumoAgua` calcula o consumo em litros e usa uma média de 15.000, enquanto `ConsumoEnergia` calcula em kWh e usa uma média de 300.

Os métodos **`gerar_alerta`** e **`atribuir_tokens`** são métodos concretos (ou *hooks* no caso de `atribuir_tokens`) implementados na classe base. Eles fornecem a lógica padrão de feedback e recompensa, que é comum a todos os tipos de consumo, mas que poderia ser sobrescrita se necessário.

## 5. Teste do Template Method

Para validar a implementação, é essencial demonstrar que o método `analisar_consumo` da classe base é executado, mas que ele chama as implementações específicas das subclasses.

### 5.1 Exemplo de Uso

```python
# ----------------------------------------------------------------------
# Exemplo de Uso (Opcional, para testes)
# ----------------------------------------------------------------------

if __name__ == "__main__":
    # Dados de exemplo do usuário
    # Consumo de Água (16000) está acima da média (15000) mas abaixo do limite de alerta (16500 = 15000 * 1.1)
    # Na verdade, o teste verifica que 18000 (20% acima) dispara o alerta. Vamos usar 16000 para um caso de economia menor.
    dados_usuario_agua = {
        "consumo_agua_litros": 14000.0, # Caso de economia: 1000 abaixo da média (15000)
        "consumo_energia_kwh": 0.0      # Ignorado por ConsumoAgua
    }
    # Consumo de Energia (320) está acima do limite de alerta (315 = 300 * 1.05)
    dados_usuario_energia = {
        "consumo_agua_litros": 0.0,     # Ignorado por ConsumoEnergia
        "consumo_energia_kwh": 320.0    # Caso de alerta: 20 acima da média (300)
    }

    print("--- Análise de Consumo de Água ---")
    analisador_agua = ConsumoAgua("usuario_teste@email.com")
    resultado_agua = analisador_agua.analisar_consumo(dados_usuario_agua)
    print(f"Consumo: {resultado_agua['consumo_atual']} | Média: {resultado_agua['media_historica']}")
    print(f"Resultado: {resultado_agua['mensagem_feedback']}")
    print(f"Tokens Ganhos: {resultado_agua['tokens_atribuidos']}")
    print("-" * 30)

    print("--- Análise de Consumo de Energia ---")
    analisador_energia = ConsumoEnergia("usuario_teste@email.com")
    resultado_energia = analisador_energia.analisar_consumo(dados_usuario_energia)
    print(f"Consumo: {resultado_energia['consumo_atual']} | Média: {resultado_energia['media_historica']}")
    print(f"Resultado: {resultado_energia['mensagem_feedback']}")
    print(f"Tokens Ganhos: {resultado_energia['tokens_atribuidos']}")
    print("-" * 30)

```

O teste deve verificar que, ao usar `ConsumoAgua`, o cálculo e as regras de alerta são específicos para água, e o mesmo para `ConsumoEnergia`.

## 6. Diagrama

### 6.1 Diagrama Template Method

O diagrama abaixo ilustra a estrutura do padrão Template Method conforme implementado, com a classe abstrata e as classes concretas:

[Diagrama do Template Method](../assets/template_method_diagrama.png)

### 6.2 Gravação da produção do Diagrama Template Method

(Espaço reservado para o link da gravação, se aplicável)

## Participação na Produção do Artefato

| Nome do Integrante | Artefato | Descrição da Contribuição | Análise Crítica |
|--------------------|----------|---------------------------|-----------------|
| [Davi Emanuel](https://github.com/daviRolvr), [Gustavo Gontijo](https://github.com/Guga301104),  [Ana Luiza](htps://github.com/luluaoreira) | Implementação Python e Documentação Template Method | Criação das classes `ConsumoTemplate`, `ConsumoAgua`, `ConsumoEnergia` e elaboração da documentação. | |

## Conclusão

O padrão Template Method se mostrou ideal para modelar o processo de análise de consumo, pois permitiu a reutilização do algoritmo principal (`analisar_consumo`) enquanto delegava as especificidades de cálculo e regra de alerta para as subclasses. Isso garante que novos tipos de consumo (e.g., Gás, Reciclagem) possam ser facilmente adicionados no futuro, simplesmente criando uma nova subclasse que implemente os métodos abstratos, sem a necessidade de reescrever a lógica de feedback e atribuição de tokens.

## Referências Bibliográficas

- Gamma, E., Helm, R., Johnson, R., & Vlissides, J. (1994). *Design Patterns: Elements of Reusable Object-Oriented Software*. Addison-Wesley.

## Histórico de Versões

| Versão | Descrição | Autor(es) | Data | Revisor(es) | Data de Revisão |
| ------ | ------------------------------------ | ------------------------------------------------------------------------------------------------- | ---------- | ----------------------------------------------------------------------------------------------------------- | --------- |
| 1.0 | Criação do documento, implementação do Template Method e código | [Davi Emanuel](https://github.com/daviRolvr), [Gustavo Gontijo](https://github.com/Guga301104),  [Ana Luiza](htps://github.com/luluaoreira)| 23/10/2025 | | |
