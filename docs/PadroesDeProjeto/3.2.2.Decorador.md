# GOF Estrutural - Decorator

## 1. Introdução

O Decorator é um tipo de GOF estrutural que tem como objetivo **"Adicionar funcionalidade a um objeto dinamicamente."**. Esse padrão é especialmente relevante no contexto do projeto, pois permite que novas responsabilidades sejam adicionadas a um serviço existente sem a necessidade de alterar a classe original. Para aplicar o padrão Decorator no projeto, foi necessário criar as classes decoradoras responsáveis por "embrulhar" o serviço principal de registro de ações.

## 2. Metodologia

Para implementar o serviço de registro de ações utilizando o padrão Decorator, os integrantes do projeto se apoiaram nos artefatos desenvolvidos na Entrega 2, especialmente o [Diagrama de Sequência – Registrar Ação Sustentável](https://github.com/UnBArqDsw2025-2-Turma02/2025.2_T02_G4_SustentabilidadeJ-_Entrega_02/blob/main/docs/Modelagem/2.2.1.DiagramaDeSequencia.md) e o [Diagrama de Pacotes](https://github.com/UnBArqDsw2025-2-Turma02/2025.2_T02_G4_SustentabilidadeJ-_Entrega_02/blob/main/docs/Modelagem/2.3.1.DiagramaDePacote.md). Essa abordagem permitiu que a implementação seguisse a arquitetura planejada, mantendo consistência na organização da aplicação.

O grupo implementou o padrão Decorator dentro da estrutura de pastas **`App/decoradores`**. Isso levou à percepção de que seria necessário atualizar o [Diagrama de Implantação](https://github.com/UnBArqDsw2025-2-Turma02/2025.2_T02_G4_SustentabilidadeJ-_Entrega_02/blob/main/docs/Modelagem/2.1.3.DiagramaImplantacao.md) para refletir a nova organização das pastas, garantindo que o diagrama permaneça fiel ao modelo atualizado. Foi decidido que essa alteração seria feita na seção de Atividades extras, mais específico em [Diagrama_de_pacotes_atualizacao](https://github.com/UnBArqDsw2025-2-Turma02/2025.2_T02_G4_SustentabilidadeJ-_Entrega_03/blob/main/docs/PadroesDeProjeto/3.4.1.Diagrama_de_pacotes_atualizacao.md)


O diagrama do Decorator foi desenvolvido pelos integrantes responsáveis com base nos materiais da professora, como slides e vídeo-aulas. A realização do diagrama foi feita inicialmente para servir como guia na implementação do código seguindo o padrão GOF Decorator, e também para auxiliar na compreensão das classes envolvidas caso seja necessário analisá-las ou utilizá-las futuramente, funcionando como uma forma de validação e documentação do artefato.



## 3. Decorator implementado no projeto

Antes de analisar o código, é importante entender os papéis dos elementos do padrão Decorator. Ele possui uma interface comum chamada "Component", que define os objetos que podem receber funcionalidades adicionais, uma classe concreta base chamada "ConcreteComponent" que representa o objeto principal, um "Decorator" que mantém referência ao objeto base e segue a mesma interface, e os "ConcreteDecorators", que implementam e acrescentam comportamentos extras ao objeto original. [1] (Gamma et al., 1994).

A seguir, estão as classes responsáveis pela implementação do padrão Strategy, separadas por arquivo e localização no projeto:

### 3.1 decorador_base.py

```python
# decorador_base.py
class AcaoDecorator:
    """Classe base para decoradores de ações sustentáveis."""

    def __init__(self, componente):
        """Inicializa decorator com componente a ser decorado."""
        self._componente = componente

    def registrar_acao(self, usuario, acao):
        """Delega registro para o componente interno."""
        return self._componente.registrar_acao(usuario, acao)
```

### 3.2 decorador_bonus.py
```python
# decorador_bonus.py
from .decorador_base import AcaoDecorator


class BonusDecorator(AcaoDecorator):
    """Decorator que adiciona bônus de 5 tokens para ações com 20+ tokens."""

    def registrar_acao(self, usuario, acao):
        """Registra ação e adiciona bônus se aplicável."""
        tokens = super().registrar_acao(usuario, acao)

        if tokens >= 20:
            usuario.saldoTokens += 5
            print(f"[BONUS] {usuario.nome} ganhou 5 tokens extras!")

        return tokens
```

### 3.3 decorador_log.py
```python
# decorador_log.py
from .decorador_base import AcaoDecorator


class LogDecorator(AcaoDecorator):
    """Decorator que adiciona logging ao registro de ações."""

    def registrar_acao(self, usuario, acao):
        """Registra ação com log."""
        print(f"[LOG] Registrando ação '{acao.tipoAcao}' de {usuario.nome}")
        return super().registrar_acao(usuario, acao)
```

### 3.4 Análise do código

O padrão Decorator permite "embrulhar" um objeto (o componente) com um ou mais decoradores para adicionar funcionalidades.

A classe `AcaoDecorator` é a base abstrata. Ela armazena uma referência ao `_componente` que está sendo decorado e, em seu método `registrar_acao`, apenas delega a chamada para esse componente.

O `LogDecorator` herda de `AcaoDecorator` e adiciona uma funcionalidade *antes* da chamada original. Ele imprime uma mensagem de log e, em seguida, usa `super()` para chamar o método `registrar_acao` do componente que ele está embrulhando (que pode ser o objeto-base ou outro decorador).

O `BonusDecorator` também herda de `AcaoDecorator`, mas adiciona uma funcionalidade *após* a chamada original. Ele primeiro chama `super()` para executar a ação e obter o número de `tokens` gerados. Com esse resultado, ele aplica sua própria lógica (verificar se `tokens >= 20`) para adicionar um bônus ao usuário.

Isso permite que o serviço-base de registro de ação seja composto dinamicamente. Por exemplo, ele pode ser "embrulhado" primeiro pelo `LogDecorator` e depois pelo `BonusDecorator`, resultando em um objeto que, ao ser chamado, executará a lógica de log, depois a lógica de registro original e, por fim, a lógica de bônus.

## 4. Teste do Decorator

Para validar a implementação do padrão Decorator, foram realizados testes que verificam se o serviço-base, quando decorado, executa as novas funcionalidades de log e bônus na ordem correta e sem alterar o comportamento principal.

### 4.1 Gravação do teste

No teste, um serviço-base de registro de ação é instanciado. Em seguida, ele é decorado com as classes `LogDecorator` e `BonusDecorator`. Duas ações são testadas: uma que gera 10 tokens (sem bônus) e outra que gera 25 tokens (com bônus). Observamos que o log foi impresso para ambas, e o bônus foi aplicado apenas na segunda, confirmando que o Decorator funciona corretamente.

[Teste Decorator](https://youtube.com/embed/wU0gt9UPjpM)

Link do vídeo pro Youtube: [Teste Decorator](https://youtu.be/wU0gt9UPjpM)

### 4.2 Print do teste

O print abaixo mostra o resultado do teste, evidenciando que as lógicas de log (executada antes) e de bônus (executada depois, condicionalmente) foram aplicadas corretamente ao serviço original.

[Print Decorator](../assets/decorator_print.png)

## 5. Diagrama

### 5.1 Diagrama Decorator

A seguir temos o diagrama do GOF Decorator:

[Diagrama do Decorator](../assets/decorator_diagrama.jpg)

### 5.2 Gravação da produção do Diagrama Decorator

A seguir está disponível a gravação em vídeo que ilustra o processo de discussão e implementação do diagrama:

[Gravação Diagrama Decorator](https://youtube.com/embed/J2H_Tz10bG8)

Link do vídeo pro Youtube: [Gravação Diagrama Strategy](https://youtu.be/J2H_Tz10bG8)



## 6. Participação na Produção do Artefato

| Nome do Integrante | Artefato | Descrição da Contribuição | Análise Crítica |
|---|---|---|---|
| Artur Mendonça Arruda | Diagrama Decorator e Documentação | Contribuição na elaboração do diagrama e na escrita da documentação do padrão. | O diagrama e o código estão perfeitamente alinhados. O ponto mais forte é a aderência ao Princípio Aberto/Fechado. A classe base, a RegistraAcaoBase no diagrama, não precisa ser alterada para que novas funcionalidades, como log e bônus, sejam adicionadas. Isso é feito apenas "embrulhando" o objeto original com os decoradores. A implementação também mostra a flexibilidade do padrão: o LogDecorator adiciona sua lógica, o print, antes de chamar o componente interno, enquanto o BonusDecorator chama o componente, pega o resultado, os tokens, e só então aplica sua lógica depois. Como análise crítica, o principal custo desse padrão é a verbosidade. Para adicionar uma simples linha de print, foi preciso criar a classe LogDecorator inteira. Em um sistema grande, isso pode levar a uma proliferação de classes muito pequenas, o que pode dificultar o gerenciamento. Outro ponto crítico é que a ordem da "pilha" de decoradores importa. O resultado de BonusDecorator(LogDecorator(base)) pode ser diferente de LogDecorator(BonusDecorator(base)). Isso coloca uma responsabilidade maior no código cliente que monta o objeto final. No geral, é uma implementação livro-texto do padrão, muito boa para garantir que o sistema seja extensível sem precisar modificar o código central. |
| Gabriel Lopes | Diagrama Decorator e Documentação | Contribuição na elaboração do diagrama e na escrita da documentação do padrão. | |
| Lucas Mendonça Arruda | Diagrama Decorator e Documentação | Contribuição na elaboração do diagrama, nos testes e na escrita da documentação do padrão. | Achei esse artefato meio complexo de trabalhar devido ao tamanho e à quantidade de classes envolvidas. Junto com minha equipe, percebemos que a estrutura atual da pasta decorators não estava refletida no diagrama de pacotes, o que indica que precisaremos atualizá-lo, o que dá mais trabalho. Apesar disso, achei bastante produtiva a parte dos diagramas e dos testes, especialmente usando a técnica de criar e explicar enquanto gravávamos, pois isso ajuda a se recordar do que foi discutido e facilita o entendimento da implementação do padrão Decorator. |

## 7. Conclusão

O padrão Decorator implementado no serviço de registro de ações mostrou ser uma solução flexível e eficiente, permitindo adicionar as responsabilidades de logging e bônus dinamicamente, sem modificar o serviço de registro original.

A aplicação do padrão foi guiada pelos diagramas de modelagem da Entrega 2, o que permitiu ao grupo manter a consistência arquitetural e assegurar que a implementação estivesse alinhada com o planejamento definido previamente.
Ademais, o diagrama e os testes do Decorator, construídos a partir da interpretação do código-fonte, confirmaram a correta estruturação das classes `AcaoDecorator`, `LogDecorator` e `BonusDecorator`.

## Referências Bibliográficas

## Bibliografia

SERRANO, Milene. Arquitetura e Desenho de Software
AULA - GOFS ESTRUTURAIS. UNB, s.d.
Disponível no sistema Aprender 3 da Universidade de Brasília. Acesso em: 24 de outubro de 2025.

## Histórico de Versões

| Versão | Descrição | Autor(es) | Data | Revisor(es) | Data de Revisão |
| --- | --- | --- | --- | --- | --- |
| 1.0 | Criação do documento, com introdução, metodologia e o código | [Artur Mendonça Arruda](https://github.com/ArtyMend07), [Gabriel Lopes ](https://github.com/BrzGab) e [Lucas Mendonça Arruda](https://github.com/lucasarruda9) | 24/10/2025 | | |
| 1.1 | Adição de teoria no tópico 3, arrumando links e metodologia e adicionando análise crítica |  [Lucas Mendonça Arruda](https://github.com/lucasarruda9) | 24/10/2025 | | |
