# Padrão Proxy

## 1. Introdução

O padrão de projeto **Proxy** é utilizado em sistemas orientados a objetos quando há a necessidade de **controlar ou restringir o acesso** a determinados objetos, adicionando uma camada intermediária entre o cliente e o objeto real. Ele é especialmente útil em cenários onde o acesso direto ao objeto pode ser custoso, inseguro ou precisar de verificações adicionais, como **autenticação**, **cache**, **lazy loading** ou **controle de permissões**.

No contexto do sistema **SustentabilidadeJá**, implementamos o padrão Proxy para gerenciar o processo de **registro de ações sustentáveis** e a **recompensa de tokens**. A classe `AcaoProxy` atua como um intermediário entre os usuários e o objeto real (`AcaoReal`). Dessa forma, o Proxy é responsável por:

1.  **Verificar a autenticação** do usuário (Controle de Acesso).
2.  Aplicar **Lazy Loading** para instanciar o objeto real (`AcaoReal`) somente quando necessário.
3.  Utilizar **Cache Persistente** para evitar o processamento de ações duplicadas e a concessão de recompensas em dobro.
4.  Garantir a **recompensa de tokens** após o registro bem-sucedido.
5.  Registrar o acesso por meio de **Logging**.

Se o usuário não estiver autenticado, o registro da ação será negado (`AcessoNegadoException`). O uso do Proxy permite separar as responsabilidades de controle de acesso, cache e recompensa das funcionalidades centrais de registro, promovendo um design mais modular e seguro.

## 2. Análise do Padrão

Para a implementação do padrão Proxy no sistema SustentabilidadeJá, adotamos uma abordagem estruturada, baseada nos princípios da programação orientada a objetos. As principais etapas e decisões foram:

### Criação da Interface Comum

Definimos a interface `IAcao`, que declara a operação principal `registrarAcao()`. Essa interface é implementada tanto pelo Proxy (`AcaoProxy`) quanto pelo objeto real (`AcaoReal`), garantindo que o cliente possa interagir com ambos de forma transparente.

### Implementação do Objeto Real

A classe `AcaoReal` contém a lógica central para o registro da ação sustentável, sendo responsável por armazenar os dados da ação (`tipo`, `descricao`, `impactoAmbiental`) e simular o processamento real no sistema.

### Desenvolvimento do Proxy

A classe `AcaoProxy` intercepta as chamadas do cliente e realiza verificações de controle de acesso, utilizando o status de autenticação do `Usuario`. Além disso, o Proxy implementa as seguintes funcionalidades adicionais:

*   **Controle de Acesso**: Verifica se o usuário está autenticado antes de permitir o registro.
*   **Lazy Loading**: O objeto `AcaoReal` é instanciado somente quando o método `registrarAcao()` é chamado pela primeira vez, evitando carregamentos desnecessários.
*   **Cache Persistente**: Utiliza o histórico do `TokenLedger` para verificar se a ação já foi registrada, otimizando o desempenho e evitando recompensas duplicadas.
*   **Recompensa**: Após o registro da ação, o Proxy integra-se ao modelo `TokenLedger` para creditar os tokens ao usuário.

### Isolamento de Responsabilidades

O Proxy (`AcaoProxy`) centraliza a lógica de controle de acesso, lazy loading, cache e recompensa, enquanto a classe `AcaoReal` foca exclusivamente no processamento e registro da ação, seguindo o princípio da **responsabilidade única**.

## 3. Modelagem

O `AcaoProxy` atua como intermediário inteligente no acesso ao serviço de registro de ações, implementando:

| Funcionalidade | Descrição |
| :--- | :--- |
| **Controle de Acesso** | Valida a autenticação do usuário antes de permitir o registro. Lança `AcessoNegadoException` quando o acesso é inadequado. |
| **Lazy Loading** | Posterga a criação do `AcaoReal` até o primeiro acesso, reduzindo a carga inicial do sistema. |
| **Cache Persistente** | Utiliza o histórico do `TokenLedger` para armazenar ações acessadas, evitando a recriação e o processamento duplicado de objetos e recompensas. |
| **Recompensa** | Integra-se ao modelo `TokenLedger` para creditar tokens ao usuário após o registro bem-sucedido da ação. |
| **Monitoramento** | Registra logs de acesso com horário e usuário. |

### 3.1 Diagrama de Classes

#### Figura 1: Diagrama UML para o Padrão Proxy (SustentabilidadeJá)

<center>
<p style="text-align: center"><b>Figura 1:</b> Diagrama UML para o Proxy utilizado no projeto.</p>

<div align="center">
  <img src="assets/DiagramaProxy.png" alt="Diagrama Proxy" >
</div>

<font size="3"><p style="text-align: center"><b>Autor:</b> <a href="">[Gustavo Gontijo Lima](https://github.com/Guga301104), [Davi Emanuel Ribeiro de Oliveira](https://github.com/daviRolvr) e [Ana Luiza Komatsu](https://github.com/luluaroeira)</a>, 2025.</p></font>
</center>

O diagrama UML apresentado representa fielmente a aplicação do padrão Proxy no contexto do SustentabilidadeJá:

*   **`AcaoProxy`** e **`AcaoReal`** implementam a interface **`IAcao`**.
*   **`AcaoProxy`** possui uma referência para **`AcaoReal`** (Lazy Load) e para **`Usuario`** (Dependência para Controle de Acesso e Recompensa).
*   A exceção **`AcessoNegadoException`** é lançada pelo **`AcaoProxy`**.

### 3.2 Descrição das Classes

| Classe | Tipo | Responsabilidade Principal |
| :--- | :--- | :--- |
| `IAcao` | Interface | Define a operação comum: `registrarAcao()`. |
| `AcaoReal` | Objeto Real | Contém a lógica central de registro da ação e cálculo do impacto. |
| `AcaoProxy` | Proxy | Intercepta a chamada, aplica Controle de Acesso, Lazy Loading, Cache Persistente e Recompensa. |
| `AcessoNegadoException` | Exceção | Lançada quando o usuário não está autenticado. |

## 4. Implementação

### 4.1 Código-Fonte

Os arquivos de código foram criados na estrutura do projeto Django/Python fornecido: `backend/App/actions/servicos/`.

#### Interface Comum: `backend/App/actions/servicos/Iacao.py`

```python
from abc import ABC, abstractmethod

class IAcao(ABC):
    """Interface comum para AcaoReal e AcaoProxy."""
    
    @abstractmethod
    def registrarAcao(self) -> str:
        """Método para registrar a ação sustentável."""
        pass
```

#### Objeto Real: `backend/App/actions/servicos/AcaoReal.py`

```python
from .Iacao import IAcao

class AcaoReal(IAcao):
    """Objeto real que contém a lógica pesada de registro da ação sustentável."""
    
    def __init__(self, tipo: str, descricao: str, impactoAmbiental: float):
        self.tipo = tipo
        self.descricao = descricao
        self.impactoAmbiental = impactoAmbiental
        
    def registrarAcao(self) -> str:
        """Simula o registro da ação sustentável no sistema."""
        # Lógica de persistência ou processamento real
        return f"[AcaoReal] Ação '{self.tipo}' registrada com sucesso. Impacto: {self.impactoAmbiental}."
```

#### Exceção: `backend/App/actions/servicos/AcessoNegadoException.py`

```python
class AcessoNegadoException(PermissionError):
    """Exceção personalizada para acesso negado."""
    def __init__(self, mensagem: str):
        super().__init__(mensagem)
```

#### Proxy (Com Cache Persistente e Recompensa): `backend/App/actions/servicos/AcaoProxy.py`

```python
from .Iacao import IAcao
from .AcaoReal import AcaoReal
from .AcessoNegadoException import AcessoNegadoException
from datetime import datetime

class AcaoProxy(IAcao):
    """
    Proxy que controla o acesso e implementa Lazy Loading, Cache Persistente e Recompensa
    para o registro de ações sustentáveis.
    """
    
    def __init__(self, usuario, tipo: str, descricao: str, impactoAmbiental: float, tokens_recompensa: int):
        self.usuario = usuario
        self.tipo = tipo
        self.descricao = descricao
        self.impactoAmbiental = impactoAmbiental
        self.tokens_recompensa = tokens_recompensa
        # Lazy Load: AcaoReal é None até ser necessária
        self.acao_real = None

    def registrarAcao(self) -> str:
        # 1. Controle de Acesso (Autenticação)
        if not getattr(self.usuario, 'is_authenticated', True):
            raise AcessoNegadoException(f"[Proxy] Acesso negado. Usuário '{getattr(self.usuario, 'username', 'Desconhecido')}' não está autenticado.")

        # 2. Verificação de Cache Persistente (Usando TokenLedger como registro de histórico)
        from App.tokens.models import TokenLedger
        
        # Verifica se já existe um crédito de tokens para esta ação
        acao_existente = TokenLedger.objects.filter(
            user=self.usuario,
            source=TokenLedger.SOURCE_ACTION,
            description=f"Recompensa por ação sustentável: {self.tipo}"
        ).exists()

        if acao_existente:
            resultado = f"[AcaoReal] Ação '{self.tipo}' registrada com sucesso. Impacto: {self.impactoAmbiental}."
            print(f"[Proxy] Ação '{self.tipo}' já registrada anteriormente por '{getattr(self.usuario, 'username', 'Desconhecido')}'. Usando Cache Persistente (TokenLedger).")
            # O Proxy retorna o resultado sem chamar AcaoReal e sem dar nova recompensa
            return resultado

        # 3. Lazy Loading: Instancia AcaoReal apenas agora
        if self.acao_real is None:
            print("[Proxy] Lazy Loading: Instanciando AcaoReal.")
            self.acao_real = AcaoReal(self.tipo, self.descricao, self.impactoAmbiental)

        # 4. Execução da Ação Real
        resultado = self.acao_real.registrarAcao()

        # 5. Recompensa (Integração com o modelo TokenLedger)
        # Cria o registro no TokenLedger, que agora também serve como "cache"
        TokenLedger.objects.create(
            user=self.usuario,
            amount=self.tokens_recompensa,
            type=TokenLedger.TYPE_CREDIT,
            source=TokenLedger.SOURCE_ACTION,
            description=f"Recompensa por ação sustentável: {self.tipo}"
        )
        print(f"[Proxy] Recompensa: {self.tokens_recompensa} tokens creditados ao usuário '{getattr(self.usuario, 'username', 'Desconhecido')}' via TokenLedger.")
            
        # 6. Logging
        print(f"[LOG] Usuário '{getattr(self.usuario, 'username', 'Desconhecido')}' registrou '{self.tipo}' em {datetime.now()}")

        return resultado
```

### 4.2 Logs e Testes

Para demonstrar a funcionalidade, utilizamos o comando de gerenciamento `registrar_acao` no terminal do Django.

#### Teste de Logs (Primeira Execução - Registro e Recompensa)

**Comando:** `python3 manage.py registrar_acao teste Reciclagem "Reciclagem de 10kg de papel" 0.8 20`

**Saída:**

```
[Proxy] Lazy Loading: Instanciando AcaoReal.
[AcaoReal] Ação 'Reciclagem' registrada com sucesso. Impacto: 0.8.
[Proxy] Recompensa: 20 tokens creditados ao usuário 'teste' via TokenLedger.
[LOG] Usuário 'teste' registrou 'Reciclagem' em [Data e Hora]
Registro de Ação BEM-SUCEDIDO: [AcaoReal] Ação 'Reciclagem' registrada com sucesso. Impacto: 0.8.
Tokens de Recompensa: 20 tokens creditados.
```

#### Teste de Cache Persistente (Segunda Execução - Otimização)

**Comando:** `python3 manage.py registrar_acao teste Reciclagem "Reciclagem de 10kg de papel" 0.8 20`

**Saída:**

```
[Proxy] Ação 'Reciclagem' já registrada anteriormente por 'teste'. Usando Cache Persistente (TokenLedger).
Registro de Ação BEM-SUCEDIDO: [AcaoReal] Ação 'Reciclagem' registrada com sucesso. Impacto: 0.8.
Tokens de Recompensa: 20 tokens creditados.
```
*A segunda execução confirma que o Proxy utilizou o histórico do TokenLedger para evitar a execução do Lazy Loading, do Objeto Real e da Recompensa, garantindo a integridade e otimização do sistema.*

## 5. Conclusão

O padrão Proxy no SustentabilidadeJá permite um acesso **seguro**, **otimizado** e **monitorado** ao serviço de registro de ações. Ao centralizar o controle de autenticação, aplicar Lazy Loading para otimização de recursos e utilizar Cache Persistente para evitar processamentos e recompensas duplicadas, o sistema se torna mais eficiente e robusto. O design modular, seguindo o princípio da responsabilidade única, garante que o sistema esteja pronto para expansões futuras.

## 6. Referências

*   REFACTORING GURU. Padrão Proxy. Disponível em: https://refactoring.guru/pt-br/design-patterns/proxy. Acesso em: 31 maio 2025.
*   GEEKSFORGEEKS. Proxy Design Pattern. Disponível em: https://www.geeksforgeeks.org/proxy-design-pattern/. Acesso em: 31 maio 2025.
*   TUTORIALSPOINT. Proxy Pattern. Disponível em: https://www.tutorialspoint.com/design_pattern/proxy_pattern.htm. Acesso em: 31 maio 2025.

### Histórico de Versão

| Versão | Data       | Alteração              | Responsável     | Revisor           | Data de revisão |
|--------|------------|------------------------|------------------|-------------------|------------------|
| `1.0` | 23/10/2025  | Criação do documento e conteúdo. | [Gustavo Gontijo Lima](https://github.com/Guga301104), [Davi Emanuel Ribeiro de Oliveira](https://github.com/daviRolvr), [Ana Luiza Komatsu](https://github.com/luluaroeira) | [Lucas Mendonça Arruda](https://github.com/lucasarruda9) | 23/10/2025 |
