# GOF Estrutural - Decorator

## 1. Introdução

O Decorator é um tipo de GOF estrutural que tem como objetivo **"Adicionar funcionalidade a um objeto dinamicamente."**. Esse padrão é especialmente relevante no contexto do projeto, pois permite que novas responsabilidades (como logging ou concessão de bônus) sejam adicionadas a um serviço existente (como o registro de ações) sem a necessidade de alterar a classe original. Para aplicar o padrão Decorator no projeto, foi necessário criar as classes decoradoras responsáveis por "embrulhar" o serviço principal de registro de ações.

## 2. Metodologia

Para implementar o serviço de registro de ações utilizando o padrão Decorator, os integrantes do projeto se apoiaram nos artefatos desenvolvidos na Entrega 2, especialmente o [Diagrama de Sequência – Registrar Ação Sustentável](https://github.com/UnBArqDsw2025-2-Turma02/2025.2_T02_G4_SustentabilidadeJ-_Entrega_02/blob/main/docs/Modelagem/2.2.1.DiagramaDeSequencia.md) e o [Diagrama de Pacotes](https://github.com/UnBArqDsw2025-2-Turma02/2025.2_T02_G4_SustentabilidadeJ-_Entrega_02/blob/main/docs/Modelagem/2.3.1.DiagramaDePacote.md). Essa abordagem permitiu que a implementação seguisse a arquitetura planejada, mantendo consistência na organização da aplicação.

Seguindo esses diagramas, o grupo manteve a consistência da arquitetura planejada, posicionando a implementação do padrão Decorator dentro da estrutura de pastas **`App/decoradores`**, conforme definido na modelagem anterior. A escolha do ambiente Django também seguiu as recomendações do [Diagrama de Implantação](https://github.com/UnBArqDsw2025-2-Turma02/2025.2_T02_G4_SustentabilidadeJ-_Entrega_02/blob/main/docs/Modelagem/2.1.3.DiagramaImplantacao.md), definindo de fato o framework de desenvolvimento do projeto.

O diagrama do Decorator foi desenvolvido pelos integrantes responsáveis com base nos materiais da professora, como slides e vídeo-aulas.  Essa abordagem pós-implementação foi adotada para garantir que o diagrama refletisse a estrutura real da aplicação. A existência do código facilitou a modelagem do diagrama, tornando o processo mais ágil e fornecendo uma referência confiável para validação futura.

## 3. Decorator implementado no projeto

A seguir, estão os códigos em python das classes que implementam o padrão Decorator:

```python
# decorador_base.py
class AcaoDecorator:
    """Classe base para decoradores de ações sustentáveis."""

    def __init__(self, componente):
        """Inicializa decorator com componente a ser decorado."""
        self._componente = componente

    def registrar_acao(self, usuario, acao):
        """Delega registro para o componente interno."""
        return self._componente.registrar_acao(usuario, acao)
````

```python
# decorador_bonus.py
from .decorador_base import AcaoDecorator


class BonusDecorator(AcaoDecorator):
    """Decorator que adiciona bônus de 5 tokens para ações com 20+ tokens."""

    def registrar_acao(self, usuario, acao):
        """Registra ação e adiciona bônus se aplicável."""
        tokens = super().registrar_acao(usuario, acao)

        if tokens >= 20:
            usuario.saldoTokens += 5
            print(f"[BONUS] {usuario.nome} ganhou 5 tokens extras!")

        return tokens
```

```python
# decorador_log.py
from .decorador_base import AcaoDecorator


class LogDecorator(AcaoDecorator):
    """Decorator que adiciona logging ao registro de ações."""

    def registrar_acao(self, usuario, acao):
        """Registra ação com log."""
        print(f"[LOG] Registrando ação '{acao.tipoAcao}' de {usuario.nome}")
        return super().registrar_acao(usuario, acao)
```

O padrão Decorator permite "embrulhar" um objeto (o componente) com um ou mais decoradores para adicionar funcionalidades.

A classe `AcaoDecorator` é a base abstrata. Ela armazena uma referência ao `_componente` que está sendo decorado e, em seu método `registrar_acao`, apenas delega a chamada para esse componente.

O `LogDecorator` herda de `AcaoDecorator` e adiciona uma funcionalidade *antes* da chamada original. Ele imprime uma mensagem de log e, em seguida, usa `super()` para chamar o método `registrar_acao` do componente que ele está embrulhando (que pode ser o objeto-base ou outro decorador).

O `BonusDecorator` também herda de `AcaoDecorator`, mas adiciona uma funcionalidade *após* a chamada original. Ele primeiro chama `super()` para executar a ação e obter o número de `tokens` gerados. Com esse resultado, ele aplica sua própria lógica (verificar se `tokens >= 20`) para adicionar um bônus ao usuário.

Isso permite que o serviço-base de registro de ação seja composto dinamicamente. Por exemplo, ele pode ser "embrulhado" primeiro pelo `LogDecorator` e depois pelo `BonusDecorator`, resultando em um objeto que, ao ser chamado, executará a lógica de log, depois a lógica de registro original e, por fim, a lógica de bônus.

## 4\. Teste do Decorator

Para validar a implementação do padrão Decorator, foram realizados testes que verificam se o serviço-base, quando decorado, executa as novas funcionalidades (log e bônus) na ordem correta e sem alterar o comportamento principal.

### 4.1 Gravação do teste

No teste, um serviço-base de registro de ação é instanciado. Em seguida, ele é decorado com as classes `LogDecorator` e `BonusDecorator`. Duas ações são testadas: uma que gera 10 tokens (sem bônus) e outra que gera 25 tokens (com bônus). Observamos que o log foi impresso para ambas, e o bônus foi aplicado apenas na segunda, confirmando que o Decorator funciona corretamente.

[](https://youtu.be/wU0gt9UPjpM)

Link do vídeo pro Youtube: [Teste Decorator](https://youtu.be/wU0gt9UPjpM)

### 4.2 Print do teste

O print abaixo mostra o resultado do teste, evidenciando que as lógicas de log (executada antes) e de bônus (executada depois, condicionalmente) foram aplicadas corretamente ao serviço original.

[Print Decorator](../assets/decorator_print.png)

## 5\. Diagrama

### 5.1 Diagrama Decorator

A seguir temos o diagrama do GOF Decorator:

[Diagrama do Decorator](../assets/decorator_diagrama.jpg)

### 5.2 Gravação da produção do Diagrama Decorator

A seguir está disponível a gravação em vídeo que ilustra o processo de discussão e implementação do diagrama:

[](https://youtu.be/5hhxbg8col4)

Link da reunião em: [https://youtube.com/embed/5hhxbg8col4](https://youtube.com/embed/5hhxbg8col4)

## 6\. Participação na Produção do Artefato

| Nome do Integrante | Artefato | Descrição da Contribuição | Análise Crítica |
|---|---|---|---|
| Artur Mendonça Arruda | Diagrama Decorator e Documentação | Contribuição na elaboração do diagrama e na escrita da documentação do padrão. | O diagrama e o código estão perfeitamente alinhados. O ponto mais forte é a aderência ao Princípio Aberto/Fechado. A classe base, a RegistraAcaoBase no diagrama, não precisa ser alterada para que novas funcionalidades, como log e bônus, sejam adicionadas. Isso é feito apenas "embrulhando" o objeto original com os decoradores. A implementação também mostra a flexibilidade do padrão: o LogDecorator adiciona sua lógica, o print, antes de chamar o componente interno, enquanto o BonusDecorator chama o componente, pega o resultado, os tokens, e só então aplica sua lógica depois. Como análise crítica, o principal custo desse padrão é a verbosidade. Para adicionar uma simples linha de print, foi preciso criar a classe LogDecorator inteira. Em um sistema grande, isso pode levar a uma proliferação de classes muito pequenas, o que pode dificultar o gerenciamento. Outro ponto crítico é que a ordem da "pilha" de decoradores importa. O resultado de BonusDecorator(LogDecorator(base)) pode ser diferente de LogDecorator(BonusDecorator(base)). Isso coloca uma responsabilidade maior no código cliente que monta o objeto final. No geral, é uma implementação livro-texto do padrão, muito boa para garantir que o sistema seja extensível sem precisar modificar o código central. |
| Gabriel Lopes | Diagrama Decorator e Documentação | Contribuição na elaboração do diagrama e na escrita da documentação do padrão. | |
| Lucas Mendonça Arruda | Diagrama Decorator e Documentação | Contribuição na elaboração do diagrama e na escrita da documentação do padrão. | |

## 7\. Conclusão

O padrão Decorator implementado no serviço de registro de ações mostrou ser uma solução flexível e eficiente, permitindo adicionar as responsabilidades de logging e bônus dinamicamente, sem modificar o serviço de registro original.

A aplicação do padrão foi guiada pelos diagramas de modelagem da Entrega 2, o que permitiu ao grupo manter a consistência arquitetural e assegurar que a implementação estivesse alinhada com o planejamento definido previamente.
Ademais, o diagrama e os testes do Decorator, construídos a partir da interpretação do código-fonte, confirmaram a correta estruturação das classes `AcaoDecorator`, `LogDecorator` e `BonusDecorator`.

## Referências Bibliográficas

## Bibliografia

SERRANO, Milene. Arquitetura e Desenho de Software
AULA - GOFS ESTRUTURAIS. UNB, s.d.
Disponível no sistema Aprender 3 da Universidade de Brasília. Acesso em: 24 de outubro de 2025.

## Histórico de Versões

| Versão | Descrição | Autor(es) | Data | Revisor(es) | Data de Revisão |
| --- | --- | --- | --- | --- | --- |
| 1.0 | Criação do documento, com introdução, metodologia e o código | [Artur Mendonça Arruda](https://github.com/ArtyMend07), [Gabriel Lopes ](https://github.com/BrzGab) e [Lucas Mendonça Arruda](https://github.com/lucasarruda9) | 24/10/2025 | | |
