# GOF Criacional - Singleton

## 1. Introdução 

O Singleton é um tipo de GOF criacional que tem como objetivo criar uma única instância e que seja facilmente acessível através de um ponto de acesso global <a id="anchor_1" href=#FRM1> [1]</a> (Gamma et al., 1994). Esse padrão é especialmente relevante no contexto do projeto, pois garante que determinados serviços mantenham uma única instância controlada, evitando inconsistências e uso desnecessário de recursos.

## 2. Contexto no Projeto

Para aplicar o padrão **Singleton** no projeto, foi necessário criar as classes responsáveis por gerenciar o serviço de tokens, implementadas utilizando o framework **Django**.  
A implementação pode ser observada no arquivo [`App/tokens/servicos/token_servico.py`](https://github.com/UnBArqDsw2025-2-Turma02/2025.2_T02_G4_SustentabilidadeJ-_Entrega_02/blob/main/App/tokens/servicos/token_servico.py), especificamente na classe **`TokenService`**, cujo propósito é **garantir uma única instância do serviço de tokens em toda a aplicação**.

A utilização desse padrão está em conformidade com os diagramas elaborados na modelagem do projeto, conforme pode ser visto em:  
- [**Diagrama de Sequência – Registrar Ação Sustentável**](https://github.com/UnBArqDsw2025-2-Turma02/2025.2_T02_G4_SustentabilidadeJ-_Entrega_02/blob/main/docs/Modelagem/2.2.1.DiagramaDeSequencia.md)  
- [**Diagrama de Pacotes**](https://github.com/UnBArqDsw2025-2-Turma02/2025.2_T02_G4_SustentabilidadeJ-_Entrega_02/blob/main/docs/Modelagem/2.3.1.DiagramaDePacote.md)


## 3. Metodologia

A organização do código foi orientada pelos **artefatos desenvolvidos na Entrega 2**, em especial o **Diagrama de Sequência** e o **Diagrama de Pacotes**, que serviram como base para estruturar o serviço responsável pelo gerenciamento de tokens.  

Seguindo esses diagramas, o grupo manteve a consistência da arquitetura planejada, posicionando a implementação do padrão **Singleton** dentro da estrutura de pastas **`App/tokens`**, conforme definido na modelagem anterior.

O **diagrama do Singleton** foi desenvolvido pelos integrantes responsáveis pelos artefatos de modelagem, com base na **interpretação direta do código-fonte** da classe `TokenService`. Esse processo de modelagem pós-implementação foi adotado para garantir que o diagrama refletisse fielmente a **estrutura real da aplicação**, assegurando a qualidade e a precisão da documentação.


## 4. Singleton implementado no projeto

A seguir, está o código em python da classe TokenService com a implementação do singleton:

```python
from .token_strategy import (
    ReciclagemStrategy, TransporteStrategy,
    EconomiaRecursosStrategy, DescarteCorretoStrategy,
    PlantioArvoreStrategy
)
import threading

class TokenService:
    """Serviço de gerenciamento de tokens usando padrões Singleton e Strategy."""

    _instance = None
    _lock = threading.Lock()

    def __new__(cls):
        """Implementa padrão Singleton."""
        if cls._instance is None:
            cls._instance = super(TokenService, cls).__new__(cls)
        return cls._instance

    def __init__(self):
        """Inicializa estratégias de cálculo de tokens."""
        if not hasattr(self, "estrategias"):
            self.estrategias = {
                "Reciclagem": ReciclagemStrategy(),
                "Transporte": TransporteStrategy(),
                "EconomiaRecursos": EconomiaRecursosStrategy(),
                "DescarteCorreto": DescarteCorretoStrategy(),
                "PlantioArvore": PlantioArvoreStrategy()
            }
            self.strategies = self.estrategias

    def registrar_tokens(self, usuario, acao):
        """Calcula e atribui tokens ao usuário baseado na ação."""
        estrategia = self.estrategias.get(acao.tipoAcao)

        if not estrategia:
            return 0

        tokens = estrategia.calcular_tokens(acao)
        usuario.saldoTokens += tokens

        return tokens

    def obter_estrategia(self, tipo_acao):
        """Retorna a estratégia de cálculo para um tipo de ação."""
        return self.estrategias.get(tipo_acao)

    def listar_tipos_disponiveis(self):
        """Lista tipos de ações disponíveis."""
        return list(self.estrategias.keys())
```

O padrão Singleton garante que apenas uma única instância do serviço de gerenciamento de tokens seja criada e utilizada em toda a aplicação. Para isso, a classe possui um atributo de classe `_instance`, que inicialmente é `None` e armazena a instância única. O método `__new__` é responsável por criar a instância apenas uma vez: se `_instance` ainda não foi definida, ele cria a instância e a salva; caso contrário, retorna a instância já existente. Dessa forma, não importa quantas vezes a classe seja instanciada, todos os pontos da aplicação receberão a mesma instância de `TokenService`.

O método `__init__` inicializa o dicionário de estratégias (`estrategias`) apenas na primeira execução, garantindo que as estratégias de cálculo de tokens sejam criadas apenas uma vez e mantidas consistentes. A verificação `if not hasattr(self, "estrategias")` impede que a re-instanciação da classe sobrescreva ou recrie as estratégias.

Além disso, a classe fornece métodos para interagir com as estratégias de tokens: `registrar_tokens` calcula e atribui tokens ao usuário com base no tipo de ação, `obter_estrategia` retorna a estratégia correspondente a um tipo de ação, e `listar_tipos_disponiveis` fornece a lista de todas as estratégias disponíveis. Todos esses métodos operam sobre a mesma instância e sobre o mesmo dicionário de estratégias, reforçando o controle centralizado do Singleton.

Para garantir a segurança em cenários concorrentes, a criação da instância única é protegida por um `Lock()`. Isso evita que múltiplos threads criem instâncias diferentes simultaneamente.


## 5. Teste do Singleton

Para validar a implementação do padrão Singleton, foram realizados testes que verificam se várias instâncias do TokenService realmente apontam para o mesmo objeto em memória, garantindo que não haja duplicação de instâncias.

### 5.1 Gravação do teste

No teste, foram criadas 3 instâncias de TokenService. Observamos que todas as instâncias compartilhavam o mesmo estado, confirmando que o Singleton funciona corretamente.

[Teste Singleton]()

### 5.2 Print do teste

O print abaixo mostra o resultado do teste, evidenciando que diferentes variáveis que receberam TokenService() apontam para o mesmo objeto.

[Print Singleton](../assets/singleton_print.png)

## 6. Diagrama

### 6.1 Diagrama Singleton

A seguir temos o diagrama do GOF Singleton: 

[Diagrama do Singleton](../assets/singleton_diagrama.jpg)


### 6.2 Gravação da produção do Diagrama Singleton

A seguir está disponível a gravação em vídeo que ilustra o processo de discussão e implementação do diagrama:

[![Assista à gravação](https://youtu.be/5hhxbg8col4)](https://youtu.be/5hhxbg8col4)

Link da reunião em: https://youtube.com/embed/5hhxbg8col4



## Participação na Produção do Artefato

| Nome do Integrante | Artefato | Descrição da Contribuição | Análise Crítica |
|--------------------|----------|---------------------------|-----------------|
| Lucas Mendonça Arruda | Diagrama Singleton e  |  |  |

## Conclusão

O padrão Singleton implementado no serviço de tokens mostrou ser uma solução eficiente para garantir que o serviço de tokens possua uma única instância acessível globalmente, evitando inconsistências e uso redundante de recursos.  

A aplicação do padrão foi guiada pelos diagramas de modelagem da Entrega 2, o que permitiu ao grupo manter a consistência arquitetural e assegurar que a implementação estivesse alinhada com o planejamento definido previamente.  
Ademais, o diagrama e os testes do Singleton construído a partir da interpretação do código-fonte confirmou a correta estruturação da classe `TokenService`.

## Referências Bibliográficas


## Bibliografia



## Histórico de Versões

| Versão | Descrição                            | Autor(es)                                                                                         | Data       | Revisor(es)                                                                                                 | Data de Revisão |
| ------ | ------------------------------------ | ------------------------------------------------------------------------------------------------- | ---------- | ----------------------------------------------------------------------------------------------------------- | --------- |
| 1.0    | Criação do documento, com introdução, metodologia e o código | [Artur Mendonça Arruda](https://github.com/ArtyMend07), [Gabriel Lopes ](https://github.com/BrzGab) e [Lucas Mendonça Arruda](https://github.com/lucasarruda9) | 23/10/2025 |  | |
| 1.1    | Adicionando explicação do código, gravação do diagrama, diagrama e print dos testes | [Artur Mendonça Arruda](https://github.com/ArtyMend07), [Gabriel Lopes ](https://github.com/BrzGab) e [Lucas Mendonça Arruda](https://github.com/lucasarruda9) | 23/10/2025 |  | |



