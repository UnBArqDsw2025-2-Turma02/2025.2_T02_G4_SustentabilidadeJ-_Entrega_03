# GOF Criacional - Singleton

## 1. Introdução 

O Singleton é um tipo de GOF criacional que tem como objetivo criar uma única instância e que seja facilmente acessível através de um ponto de acesso global <a id="anchor_1" href=#FRM1> [1]</a> (Gamma et al., 1994). Esse padrão é especialmente relevante no contexto do projeto, pois garante que determinados serviços mantenham uma única instância controlada, evitando inconsistências e uso desnecessário de recursos. Para aplicar o padrão Singleton no projeto, foi necessário criar as classes responsáveis por gerenciar o serviço de tokens, implementadas utilizando o framework Django. 

## 2. Metodologia

Para implementar o serviço de gerenciamento de tokens utilizando o padrão Singleton, os integrantes do projeto se apoiaram nos artefatos desenvolvidos na Entrega 2, especialmente o [Diagrama de Sequência – Registrar Ação Sustentável](https://github.com/UnBArqDsw2025-2-Turma02/2025.2_T02_G4_SustentabilidadeJ-_Entrega_02/blob/main/docs/Modelagem/2.2.1.DiagramaDeSequencia.md) e o [Diagrama de Pacotes](https://github.com/UnBArqDsw2025-2-Turma02/2025.2_T02_G4_SustentabilidadeJ-_Entrega_02/blob/main/docs/Modelagem/2.3.1.DiagramaDePacote.md). Essa abordagem permitiu que a implementação seguisse a arquitetura planejada, mantendo consistência na organização da aplicação e garantindo que o serviço de tokens fosse centralizado e acessível de forma única em toda a aplicação.

Seguindo esses diagramas, o grupo manteve a consistência da arquitetura planejada, posicionando a implementação do padrão Singleton dentro da estrutura de pastas **`App/tokens`**, conforme definido na modelagem anterior. A escolha do ambiente Django também seguiu as recomendações do [Diagrama de Implantação](https://github.com/UnBArqDsw2025-2-Turma02/2025.2_T02_G4_SustentabilidadeJ-_Entrega_02/blob/main/docs/Modelagem/2.1.3.DiagramaImplantacao.md), definindo de fato o framework de desenvolvimento do projeto.

O diagrama do Singleton foi desenvolvido pelos integrantes responsáveis com base nos materiais da professora, como slides e vídeo-aulas, no livro Design Patterns: Elements of Reusable Object-Oriented Software e na interpretação direta do código-fonte da classe TokenService. Essa abordagem pós-implementação foi adotada para garantir que o diagrama refletisse a estrutura real da aplicação. A existência do código facilitou a modelagem do diagrama, tornando o processo mais ágil e fornecendo uma referência confiável para validação futura e para entregas subsequentes que necessitem analisar ou estender o serviço de tokens.

## 3. Singleton implementado no projeto

A seguir, está o código em python da classe TokenService com a implementação do singleton:

```python
from .token_strategy import (
    ReciclagemStrategy, TransporteStrategy,
    EconomiaRecursosStrategy, DescarteCorretoStrategy,
    PlantioArvoreStrategy
)
import threading

class TokenService:
    """Serviço de gerenciamento de tokens usando padrões Singleton e Strategy."""

    _instance = None
    _lock = threading.Lock()

    def __new__(cls):
        """Implementa padrão Singleton."""
        if cls._instance is None:
            cls._instance = super(TokenService, cls).__new__(cls)
        return cls._instance

    def __init__(self):
        """Inicializa estratégias de cálculo de tokens."""
        if not hasattr(self, "estrategias"):
            self.estrategias = {
                "Reciclagem": ReciclagemStrategy(),
                "Transporte": TransporteStrategy(),
                "EconomiaRecursos": EconomiaRecursosStrategy(),
                "DescarteCorreto": DescarteCorretoStrategy(),
                "PlantioArvore": PlantioArvoreStrategy()
            }
            self.strategies = self.estrategias

    def registrar_tokens(self, usuario, acao):
        """Calcula e atribui tokens ao usuário baseado na ação."""
        estrategia = self.estrategias.get(acao.tipoAcao)

        if not estrategia:
            return 0

        tokens = estrategia.calcular_tokens(acao)
        usuario.saldoTokens += tokens

        return tokens

    def obter_estrategia(self, tipo_acao):
        """Retorna a estratégia de cálculo para um tipo de ação."""
        return self.estrategias.get(tipo_acao)

    def listar_tipos_disponiveis(self):
        """Lista tipos de ações disponíveis."""
        return list(self.estrategias.keys())
```

O padrão Singleton garante que apenas uma única instância do serviço de gerenciamento de tokens seja criada e utilizada em toda a aplicação. Para isso, a classe possui um atributo de classe `_instance`, que inicialmente é `None` e armazena a instância única. O método `__new__` é responsável por criar a instância apenas uma vez: se `_instance` ainda não foi definida, ele cria a instância e a salva; caso contrário, retorna a instância já existente. Dessa forma, não importa quantas vezes a classe seja instanciada, todos os pontos da aplicação receberão a mesma instância de `TokenService`.

O método `__init__` inicializa o dicionário de estratégias (`estrategias`) apenas na primeira execução, garantindo que as estratégias de cálculo de tokens sejam criadas apenas uma vez e mantidas consistentes. A verificação `if not hasattr(self, "estrategias")` impede que a re-instanciação da classe sobrescreva ou recrie as estratégias.

Além disso, a classe fornece métodos para interagir com as estratégias de tokens: `registrar_tokens` calcula e atribui tokens ao usuário com base no tipo de ação, `obter_estrategia` retorna a estratégia correspondente a um tipo de ação, e `listar_tipos_disponiveis` fornece a lista de todas as estratégias disponíveis. Todos esses métodos operam sobre a mesma instância e sobre o mesmo dicionário de estratégias, reforçando o controle centralizado do Singleton.

Para garantir a segurança em cenários concorrentes, a criação da instância única é protegida por um `Lock()`. Isso evita que múltiplos threads criem instâncias diferentes simultaneamente.


## 4. Teste do Singleton

Para validar a implementação do padrão Singleton, foram realizados testes que verificam se várias instâncias do TokenService realmente apontam para o mesmo objeto em memória, garantindo que não haja duplicação de instâncias.

### 4.1 Gravação do teste

No teste, foram criadas 3 instâncias de TokenService. Observamos que todas as instâncias compartilhavam o mesmo estado, confirmando que o Singleton funciona corretamente.

[Teste Singleton](https://youtube.com/embed/RYR31CU8nts)

Link do vídeo pro Youtube: [Teste Singleton](https://youtu.be/RYR31CU8nts)

### 4.2 Print do teste

O print abaixo mostra o resultado do teste, evidenciando que diferentes variáveis que receberam TokenService() apontam para o mesmo objeto.

[Print Singleton](../assets/singleton_print.png)

## 5. Diagrama

### 5.1 Diagrama Singleton

A seguir temos o diagrama do GOF Singleton: 

[Diagrama do Singleton](https://raw.githubusercontent.com/UnBArqDsw2025-2-Turma02/2025.2_T02_G4_SustentabilidadeJ-_Entrega_03/refs/heads/docs/Singleton/docs/assets/singleton_diagrama.jpg)


### 5.2 Gravação da produção do Diagrama Singleton

A seguir está disponível a gravação em vídeo que ilustra o processo de discussão e implementação do diagrama:

[![Assista à gravação](https://youtu.be/5hhxbg8col4)](https://youtu.be/5hhxbg8col4)

Link da reunião em: https://youtube.com/embed/5hhxbg8col4



## 6. Participação na Produção do Artefato

| Nome do Integrante | Artefato | Descrição da Contribuição | Análise Crítica |
|--------------------|----------|---------------------------|-----------------|
| Artur Mendonça Arruda | Diagrama Singleton, código  | Contribui na documentação do artefato, como na gravação / upload do vídeo de testes, participei ativamente na criação e consolidação do diagrama singleton. |  Em minha análise do padrão Singleton, a primeira coisa que notei foi o quão surpreendentemente simples o diagrama de classes é. Ele basicamente mostra uma classe, TokenService, com seus métodos e um cliente que a utiliza. Enquanto isso, o código me causou um sentimento inversamente proporcional, especialmente por causa da criação do semáforo para não permetir que uma instância concorra com outra na região crítica do código. |
| Lucas Mendonça Arruda | Diagrama Singleton, código  | Contribui na documentação do artefato, como na elaboração da metodologia e a conclusão, além de participar da criação do diagrama Singleton, auxiliando na produção dos vídeos explicativos sobre o artefato. | Considerei o artefato bastante desafiador por envolver manipulação de código, mas achei que o desenvolvimento dos diagramas e do artefato em equipe tornou mais fácil solucionar problemas e criar artefatos. Achei que o diagrama e os códigos estavam coerentes e condizentes com o conceito do padrão Singleton. |

## 7. Conclusão

O padrão Singleton implementado no serviço de tokens mostrou ser uma solução eficiente para garantir que o serviço de tokens possua uma única instância acessível globalmente, evitando inconsistências e uso redundante de recursos.  

A aplicação do padrão foi guiada pelos diagramas de modelagem da Entrega 2, o que permitiu ao grupo manter a consistência arquitetural e assegurar que a implementação estivesse alinhada com o planejamento definido previamente.  
Ademais, o diagrama e os testes do Singleton construído a partir da interpretação do código-fonte confirmou a correta estruturação da classe `TokenService`.

## Referências Bibliográficas

> <a id="FRM1" href="#anchor_1">1.</a>GAMMA, Erich; HELM, Richard; JOHNSON, Ralph; VLISSIDES, John. *Design Patterns: Elements of Reusable Object-Oriented Software*. Boston: Addison-Wesley, 1994.
![livro Design Patterns](https://raw.githubusercontent.com/UnBArqDsw2025-2-Turma02/2025.2_T02_G4_SustentabilidadeJ-_Entrega_03/refs/heads/docs/Singleton/docs/assets/referencias/singleton_ref.png)

## Bibliografia

SERRANO, Milene. Arquitetura e Desenho de Software
AULA - GOFS CRIACIONAIS. UNB, s.d. 
Disponível em: <https://aprender3.unb.br/pluginfile.php/3178542/mod_page/content/1/Arquitetura%20e%20Desenho%20de%20Software%20-%20Aula%20GoFs%20Criacionais%20-%20Profa.%20Milene.pdf>. Acesso em: 23 de outubro de 2025.

SERRANO, Milene. 08d - Video-Aula - DSW - GoFs - Criacionais - Demais - Somente visualização. UNB, s.d. 
Disponível em: <https://unbbr-my.sharepoint.com/personal/mileneserrano_unb_br/_layouts/15/stream.aspx?id=%2Fpersonal%2Fmileneserrano%5Funb%5Fbr%2FDocuments%2FArqDSW%20%2D%20V%C3%ADdeosOriginais%2F08d%20%2D%20Video%2DAula%20%2D%20DSW%20%2D%20GoFs%20%2D%20Criacionais%20%2D%20Demais%2Emp4&ga=1&referrer=StreamWebApp%2EWeb&referrerScenario=AddressBarCopied%2Eview%2E0f7b2e2c%2D0744%2D431e%2D9e62%2D0be8ff5d3836>. Acesso em: 23 de outubro de 2025.

GAMMA, Erich; HELM, Richard; JOHNSON, Ralph; VLISSIDES, John. *Design Patterns: Elements of Reusable Object-Oriented Software*. Boston: Addison-Wesley, 1994.


## Histórico de Versões

| Versão | Descrição                            | Autor(es)                                                                                         | Data       | Revisor(es)                                                                                                 | Data de Revisão |
| ------ | ------------------------------------ | ------------------------------------------------------------------------------------------------- | ---------- | ----------------------------------------------------------------------------------------------------------- | --------- |
| 1.0    | Criação do documento, com introdução, metodologia e o código | [Artur Mendonça Arruda](https://github.com/ArtyMend07), [Gabriel Lopes ](https://github.com/BrzGab) e [Lucas Mendonça Arruda](https://github.com/lucasarruda9) | 23/10/2025 |  | |
| 1.1    | Adicionando explicação do código, gravação do diagrama, diagrama e print dos testes | [Artur Mendonça Arruda](https://github.com/ArtyMend07), [Gabriel Lopes ](https://github.com/BrzGab) e [Lucas Mendonça Arruda](https://github.com/lucasarruda9) | 23/10/2025 |  | |
| 1.2    | refinando metodologia, adicionando referências e rastreabilidade com outras entregas| [Artur Mendonça Arruda](https://github.com/ArtyMend07), [Gabriel Lopes ](https://github.com/BrzGab) e [Lucas Mendonça Arruda](https://github.com/lucasarruda9) | 23/10/2025 |  | |
| 1.3    | Adição de informações e análise crítica na tabela de participações | [Artur Mendonça Arruda](https://github.com/ArtyMend07) | 23/10/2025 |  | |




