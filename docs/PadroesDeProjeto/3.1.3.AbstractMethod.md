# 3.1.4. Abstract Factory - SustentabilidadeJá


## 1. Introdução

No desenvolvimento orientado a objetos, é comum a necessidade de criar grupos de objetos que pertençam a uma mesma família, mantendo compatibilidade entre eles e evitando o acoplamento direto entre o código cliente e as classes concretas.  
O uso direto de `new` pode gerar dependências rígidas, dificultando a manutenção e a expansão do sistema.

O padrão de projeto criacional **Abstract Factory** resolve esse problema ao fornecer uma interface para criar famílias de objetos relacionados ou dependentes sem especificar suas classes concretas.  
Isso promove **baixo acoplamento**, **alta coesão** e **facilidade de expansão**.

No contexto do projeto **SustentabilidadeJá**, o padrão foi utilizado para gerenciar diferentes tipos de ações sustentáveis, como reciclagem, transporte público e economia de energia, que seguem o mesmo fluxo (**registro → cálculo de tokens → emissão de recompensa**), mas possuem regras específicas.  
O **Abstract Factory** permite tratar essas variações como famílias de objetos compatíveis, sem alterar o código cliente.


## 2. Metodologia

A aplicação do padrão seguiu quatro etapas principais:

### 2.1. Análise do Domínio

Foram identificadas as ações sustentáveis que compõem o sistema, todas seguindo a mesma estrutura:

- Registrar uma ação sustentável;
- Calcular tokens gerados;
- Emitir uma recompensa (cupom, desconto ou benefício).

Cada tipo de ação (Reciclagem, Transporte, Energia) forma uma família de objetos relacionados, o que justificou o uso do **Abstract Factory**.

### 2.2. Modelagem da Solução

A estrutura projetada define:

- **Fábrica Abstrata:** `SustainabilityFactory`  
  Define métodos para criar `ActionLogger`, `TokenCalculator` e `RewardIssuer`.

- **Fábricas Concretas:**  
  `RecyclingFactory`, `PublicTransportFactory` e `EnergySavingFactory` implementam a interface e geram produtos específicos.

- **Produtos Abstratos:**  
  `ActionLogger`, `TokenCalculator` e `RewardIssuer`.

- **Produtos Concretos:**  
  Implementações específicas para cada tipo de ação sustentável, como `RecyclingLogger`, `PublicTransportTokenCalculator`, `EnergySavingRewardIssuer`, etc.

### 2.3. Tecnologias Utilizadas

| Elemento | Especificação |
|-----------|----------------|
| **Linguagem** | Java |
| **Paradigma** | Orientação a Objetos |
| **Padrão** | Abstract Factory (GoF Criacional) |
| **Ambiente** | VS Code / IntelliJ IDEA |
| **Versão JDK** | 17+ |


## 3. Implementação

### 3.1. Interfaces dos Produtos Abstratos

```java
// ActionLogger.java
package br.com.sustentabilidadeja.factory;
import java.util.Map;

public interface ActionLogger {
    boolean logAction(String userId, Map<String, Object> payload);
}

// TokenCalculator.java
package br.com.sustentabilidadeja.factory;
import java.util.Map;

public interface TokenCalculator {
    int calculateTokens(Map<String, Object> payload);
}
// RewardIssuer.java
package br.com.sustentabilidadeja.factory;
public interface RewardIssuer {
    String issueReward(String userId, int tokens);
}
```
```java
### 3.2. Interface da Fábrica Abstrata

```java
// SustainabilityFactory.java
package br.com.sustentabilidadeja.factory;

public interface SustainabilityFactory {
    ActionLogger createLogger();
    TokenCalculator createCalculator();
    RewardIssuer createRewardIssuer();
}
```
### 3.3. Fábricas e Produtos Concretos

```java
// Fábrica de Reciclagem
package br.com.sustentabilidadeja.factory.recycling;
import br.com.sustentabilidadeja.factory.*;
import java.util.Map;

public class RecyclingLogger implements ActionLogger {
    public boolean logAction(String userId, Map<String, Object> payload) {
        System.out.println("[RECICLAGEM] Usuário " + userId + " registrou: " + payload);
        return true;
    }
}

public class RecyclingTokenCalculator implements TokenCalculator {
    public int calculateTokens(Map<String, Object> payload) {
        double kg = ((Number) payload.getOrDefault("kg", 0)).doubleValue();
        return (int) Math.floor(kg / 0.5);
    }
}

public class RecyclingRewardIssuer implements RewardIssuer {
    public String issueReward(String userId, int tokens) {
        return "[RECICLAGEM] " + tokens + " tokens creditados (cupom ecológico emitido)";
    }
}

public class RecyclingFactory implements SustainabilityFactory {
    public ActionLogger createLogger() { return new RecyclingLogger(); }
    public TokenCalculator createCalculator() { return new RecyclingTokenCalculator(); }
    public RewardIssuer createRewardIssuer() { return new RecyclingRewardIssuer(); }
}
//  Fábrica de Transporte Público
package br.com.sustentabilidadeja.factory.transport;
import br.com.sustentabilidadeja.factory.*;
import java.util.Map;

public class PublicTransportLogger implements ActionLogger {
    public boolean logAction(String userId, Map<String, Object> payload) {
        System.out.println("[TRANSPORTE] Ação registrada: " + payload);
        return true;
    }
}

public class PublicTransportTokenCalculator implements TokenCalculator {
    public int calculateTokens(Map<String, Object> payload) {
        int viagens = ((Number) payload.getOrDefault("viagens", 0)).intValue();
        return viagens * 2;
    }
}

public class PublicTransportRewardIssuer implements RewardIssuer {
    public String issueReward(String userId, int tokens) {
        return "[TRANSPORTE] " + tokens + " tokens convertidos em créditos de mobilidade.";
    }
}

public class PublicTransportFactory implements SustainabilityFactory {
    public ActionLogger createLogger() { return new PublicTransportLogger(); }
    public TokenCalculator createCalculator() { return new PublicTransportTokenCalculator(); }
    public RewardIssuer createRewardIssuer() { return new PublicTransportRewardIssuer(); }
}

// Fábrica de economia de energia
package br.com.sustentabilidadeja.factory.energy;
import br.com.sustentabilidadeja.factory.*;
import java.util.Map;

public class EnergySavingLogger implements ActionLogger {
    public boolean logAction(String userId, Map<String, Object> payload) {
        System.out.println("[ENERGIA] Ação registrada: " + payload);
        return true;
    }
}

public class EnergySavingTokenCalculator implements TokenCalculator {
    public int calculateTokens(Map<String, Object> payload) {
        double kwh = ((Number) payload.getOrDefault("kwh", 0)).doubleValue();
        return Math.min(20, (int) Math.floor(kwh));
    }
}

public class EnergySavingRewardIssuer implements RewardIssuer {
    public String issueReward(String userId, int tokens) {
        return "[ENERGIA] " + tokens + " tokens convertidos em desconto na conta de luz.";
    }
}

public class EnergySavingFactory implements SustainabilityFactory {
    public ActionLogger createLogger() { return new EnergySavingLogger(); }
    public TokenCalculator createCalculator() { return new EnergySavingTokenCalculator(); }
    public RewardIssuer createRewardIssuer() { return new EnergySavingRewardIssuer(); }
}


```

### 3.4. Classe Cliente (Uso do Abstract Factory)

```java
package br.com.sustentabilidadeja;
import br.com.sustentabilidadeja.factory.*;
import br.com.sustentabilidadeja.factory.recycling.*;
import java.util.HashMap;
import java.util.Map;

public class App {
    public static void main(String[] args) {
        SustainabilityFactory factory = new RecyclingFactory();

        Map<String, Object> payload = new HashMap<>();
        payload.put("kg", 2.5);

        ActionLogger logger = factory.createLogger();
        TokenCalculator calc = factory.createCalculator();
        RewardIssuer reward = factory.createRewardIssuer();

        logger.logAction("user001", payload);
        int tokens = calc.calculateTokens(payload);
        System.out.println(reward.issueReward("user001", tokens));
    }
}
```

## 4. Modelagem do Abstract Factory

**Figura 1 - Diagrama UML do Abstract Factory (SustentabilidadeJá)**

![Diagrama UML - Abstract Factory](../imagens/abstract-factory.png)

**Fonte:** Ana Luiza Komatsu


## 5. Senso Crítico e Trabalho em Equipe

A adoção do padrão **Abstract Factory** no projeto *SustentabilidadeJá* trouxe benefícios claros:

- **Desacoplamento:** o cliente não conhece as classes concretas de cada tipo de ação.  
- **Extensibilidade:** novas ações (ex.: economia de água, plantio de árvores) podem ser adicionadas criando novas fábricas e produtos, sem alterar o código existente.  
- **Coerência:** cada fábrica gera apenas produtos compatíveis entre si, garantindo consistência no fluxo de criação.

O trabalho em equipe envolveu a **análise do domínio**, **modelagem**, **codificação** e **geração do diagrama UML**.  
A integração entre design e implementação assegurou que o padrão fosse aplicado corretamente conforme as boas práticas da disciplina.


## 6. Conclusão

O padrão **Abstract Factory** se mostrou ideal para o domínio do *SustentabilidadeJá*, ao permitir a criação de famílias completas de objetos relacionados (registro, cálculo e recompensa) sem acoplamento direto entre classes concretas.  
O resultado é uma arquitetura mais **modular**, **coesa** e preparada para futuras expansões, além de reforçar os princípios **SOLID** de design orientado a objetos.


## 7. Referências

- **SERRANO, Milene.** *Arquitetura e Desenho de Software - Aula GoFs Criacionais.* Universidade de Brasília, 2025.  
- **Refactoring.Guru**  *https://refactoring.guru/pt-br/design-patterns/abstract-factory*  
- **Wikipedia (2023)**  *https://pt.wikipedia.org/wiki/Abstract_factory*  
- **MIRANDA, Nelson.** *Desvendando os Padrões de Projeto: Abstract Factory e Factory Method.* Medium, 2023.

## Vídeo de explicação do diagrama de UML Abstract Factory

https://youtu.be/anJKE48r9Lw

## Participação na Produção do Artefato

| Nome do Integrante | Artefato | Descrição da Contribuição | Análise Crítica |
|--------------------|----------|---------------------------|-----------------|
| Ana Luiza Komatsu | Abstract Method  |  |  |
| Gustavo Gontijo | Abstract Method  |  |  |
| Davi Emanuel | Abstract Method  |  |  |

## Histórico de Versões
@@ -150,6 +151,7 @@ Abstract Method
| ------ | ------------------------------------ | ------------------------------------------------------------------------------------------------- | ---------- | ----------------------------------------------------------------------------------------------------------- | --------- |
| 1.0    | Criação do documento, com introdução, metodologia, o código e diagrama | [Ana Luiza Komatsu](https://github.com/luluaroeira), [Gustavo Gontijo](https://github.com/Guga301104) e [Davi Emanuel](https://github.com/daviRolvr) | 23/10/2025 |  | |
| 1.1    | Adicionando explicação do código e gravação do diagrama| [Ana Luiza Komatsu](https://github.com/luluaroeira), [Gustavo Gontijo](https://github.com/Guga301104) e [Davi Emanuel](https://github.com/daviRolvr) | 24/10/2025 |  | |






